.
├── backend
│   ├── db
│   │   ├── db_engine.py
│   │   ├── db_generete_schema_model.py
│   │   ├── db_utils.py
│   │   └── schema_models.py
│   ├── environment.yml
│   ├── financialmodelingprep
│   │   └── fmp_stocks.py
│   ├── main.py
│   ├── requirements.txt
│   └── tests
│       └── test_db_operations.py
├── client
│   ├── .env.local
│   ├── .gitignore
│   ├── jsconfig.json
│   ├── package.json
│   ├── package-lock.json
│   ├── README.md
│   └── src
│       ├── App.js
│       ├── assets
│       │   └── profile.jpeg
│       ├── components
│       │   ├── DataGridCustomToolbar.jsx
│       │   ├── FlexBetween.jsx
│       │   ├── Header.jsx
│       │   ├── Navbar.jsx
│       │   └── Sidebar.jsx
│       ├── index.css
│       ├── index.js
│       ├── scenes
│       │   ├── dashboard
│       │   │   └── index.jsx
│       │   ├── layout
│       │   │   └── index.jsx
│       │   └── transactions
│       │       └── index.jsx
│       ├── state
│       │   ├── api.js
│       │   └── index.js
│       └── theme.js
├── custom_tree_and_files_corrected.txt
├── .env
├── frontend
│   ├── .env
│   ├── .gitignore
│   ├── package.json
│   ├── package-lock.json
│   ├── README.md
│   └── src
│       ├── App.css
│       ├── App.js
│       ├── App.test.js
│       ├── index.css
│       ├── index.js
│       ├── logo.svg
│       ├── reportWebVitals.js
│       └── setupTests.js
├── .gitignore
├── LICENSE
├── notebooks
│   ├── database.db
│   └── read_data_v0.1.ipynb
├── README.md
└── scripts
    ├── populate_db.py
    └── print_tree_and_files_script.py

18 directories, 52 files


=== Content of README.md ===


# Finance Data Driven

Progetto con il quale in seguito all'elaborazione dati questi vengono salvati in un db, e i dati dal db vengono letti dal frontend react per essere interrogati

Requisiti funzionali:

Voglio creare una web app che che parla di finanza, sia attraverso contenuti scritti sia attraverso l’analisi dinamica dei dati finanziari con tabelle e grafici, con i seguenti requisiti funzionali di base:

- home page che introduce al sito web e spiega cosa fa
- una pagina di alert in cui è contenuta una tabella con dei dati relativi a vari asset. La tabella è letta da un db che al momento si tratta essere di un db sqlachemy
- altra sezione formato blog con un elenco di articoli


## Introduction
This repository is dedicated to data-driven financial analysis and models. The codebase primarily utilizes the OpenBB library for data fetching and analysis.

Nella parte di notebook lavoreremo con openBB in modo da richiamare i dati e storicizzarli o in una data lake house o un un DB



## Installation


### Install OpenBB

For a complete guide on installing OpenBB, refer to the official documentation [here](https://docs.openbb.co/terminal/installation/pypi).

In this specific case, the following commands were executed to set up the environment and install OpenBB:

1. Create a new conda environment:
```bash
conda env create -n obb --file https://raw.githubusercontent.com/OpenBB-finance/OpenBBTerminal/main/build/conda/conda-3-9-env.yaml
```

2. Activate the conda environment:
```bash
conda activate obb
```

3. Install OpenBB:
```bash
pip install openbb --no-cache-dir
```



Aggiungi il file .env al backend con le credenziali

FMP_SECRET_KEY=<your_key>
DATABASE_PATH=<your_database>


Per lavorare con il backend

cd backend
conda env create -f environment.yml


=== Content of backend/main.py ===

from fastapi import FastAPI, HTTPException, Depends
from db.db_utils import table_exists, get_periods_and_tickers, get_filtered_data
from db.db_engine import Session as SessionLocal
from dotenv import load_dotenv
import os

app = FastAPI()

from fastapi.middleware.cors import CORSMiddleware

# Set up CORS
origins = [
    "http://localhost:3000",   # This is where your React app might run in development
    "http://localhost:8000",   # This is where your FastAPI backend might run
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

load_dotenv()

DATABASE_PATH = os.getenv("DATABASE_PATH")
if not DATABASE_PATH:
    raise ValueError("DATABASE_PATH environment variable is not set. Please define it in the .env file.")


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


@app.get("/db-check")
def check_db_connection():
    try:
        if table_exists("any_table_name"):
            return {"status": "success", "message": "Connected to the database successfully!"}
        else:
            return {
                "status": "success",
                "message": "Connected to the database successfully, but the specified table does not exist.",
            }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/fa-balance/options")
def get_fa_balance_options(db: SessionLocal = Depends(get_db)):
    return get_periods_and_tickers(db)


@app.get("/fa-balance/")
def get_fa_balance_data(period: str, ticker: str, db: SessionLocal = Depends(get_db)):
    return get_filtered_data(db, period, ticker)

=== Content of backend/db/db_engine.py ===

# from sqlalchemy import create_engine
# from sqlalchemy.orm import sessionmaker
# import yaml
# import os

# dir_path = os.path.dirname(os.path.realpath(__file__))

# credentials_path = os.path.join(dir_path, "..", "credentials.yaml")
# with open(credentials_path, "r") as file:
#     config = yaml.safe_load(file)

# # Check if we are in TEST_MODE
# if os.environ.get("TEST_MODE") == "true":
#     database_path = os.path.join(dir_path, "..", "test_value_invest.db")
# else:
#     database_path = os.path.join(dir_path, "..", config["database"]["file"])

# engine = create_engine(f"sqlite:///{database_path}")

# Session = sessionmaker(bind=engine)

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
import os
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

dir_path = os.path.dirname(os.path.realpath(__file__))

# Fetch the database path from environment variable
database_path = os.getenv("DATABASE_PATH")
if not database_path:
    raise ValueError("DATABASE_PATH environment variable is not set. Please define it in the .env file.")

engine = create_engine(f"sqlite:///{database_path}")

Session = sessionmaker(bind=engine)


=== Content of backend/db/db_utils.py ===

from .db_engine import Session
from sqlalchemy.orm import sessionmaker
import pandas as pd
from sqlalchemy import inspect, text


def table_exists(table_name):
    """Verifica se la tabella esiste nel database."""
    with Session() as session:
        inspector = inspect(session.bind)
        return table_name in inspector.get_table_names()


def bulk_insert_data_from_dataframe(TableClass, dataframe):
    """Inserisci tutti i record del dataframe nella tabella. Se la tabella non esiste, creala."""
    with Session() as session:
        if not table_exists(TableClass.__tablename__):
            print(f"Creating table {TableClass.__tablename__}...")
            TableClass.__table__.create(bind=session.bind)
        # Inserisci tutti i record del dataframe in bulk
        data = dataframe.to_dict(orient="records")
        session.bulk_insert_mappings(TableClass, data)
        session.commit()


def read_table_data(table_name):
    """Read all records from the specified table."""
    with Session() as session:
        inspector = inspect(session.bind)
        if table_name in inspector.get_table_names():
            query_result = session.execute(text(f"SELECT * FROM {table_name}"))
            column_names = query_result.keys()
            result = query_result.fetchall()
            return pd.DataFrame(result, columns=column_names)
        else:
            print(f"The table {table_name} does not exist in the database.")
            return pd.DataFrame()


from .schema_models import Balance


def get_periods_and_tickers(session):
    periods = session.query(Balance.period).distinct().all()
    tickers = session.query(Balance.ticker).distinct().all()
    return {"periods": [x[0] for x in periods], "tickers": [x[0] for x in tickers]}


def get_filtered_data(session, period, ticker):
    return session.query(Balance).filter_by(period=period, ticker=ticker).all()

=== Content of backend/db/schema_models.py ===

from sqlalchemy import BigInteger, Column, DateTime, Float, Integer, String, Table, Text, Date
from sqlalchemy.ext.declarative import declarative_base

from .db_engine import engine

Base = declarative_base()


# Define the table with a name, columns, and constraints
class LogAvailableTickers(Base):
    __tablename__ = "log_available_tickers"

    id = Column(Integer, primary_key=True)
    timestamp = Column(DateTime, nullable=False)
    num_companies = Column(Integer, nullable=False)
    num_tickers = Column(Integer, nullable=False)


class LogIngestedTickers(Base):
    __tablename__ = "log_ingested_tickers"

    id = Column(Integer, primary_key=True)
    ingestion_timestamp = Column(DateTime, nullable=False)
    ticker = Column(String, nullable=False)
    num_new_rows = Column(Integer, nullable=False)
    num_old_rows_diff_dates = Column(Integer, nullable=False)
    num_columns = Column(Integer, nullable=False)


class Balance(Base):
    __tablename__ = "fa_balance"
    fiscal_date_ending = Column(String)
    reported_currency = Column(String)
    cik = Column(String, primary_key=True)
    filling_date = Column(Date, primary_key=True)
    accepted_date = Column(Date, primary_key=True)
    calendar_year = Column(Date, primary_key=True)
    period = Column(String, primary_key=True)
    cash_and_cash_equivalents = Column(String)
    short_term_investments = Column(String)
    cash_and_short_term_investments = Column(String)
    net_receivables = Column(String)
    inventory = Column(String)
    other_current_assets = Column(String)
    total_current_assets = Column(String)
    property_plant_equipment_net = Column(String)
    goodwill = Column(String)
    intangible_assets = Column(String)
    goodwill_and_intangible_assets = Column(String)
    long_term_investments = Column(String)
    tax_assets = Column(String)
    other_non_current_assets = Column(String)
    total_non_current_assets = Column(String)
    other_assets = Column(String)
    total_assets = Column(String)
    account_payables = Column(String)
    short_term_debt = Column(String)
    tax_payables = Column(String)
    deferred_revenue = Column(String)
    other_current_liabilities = Column(String)
    total_current_liabilities = Column(String)
    long_term_debt = Column(String)
    deferred_revenue_non_current = Column(String)
    deferred_tax_liabilities_non_current = Column(String)
    other_non_current_liabilities = Column(String)
    total_non_current_liabilities = Column(String)
    other_liabilities = Column(String)
    capital_lease_obligations = Column(String)
    total_liabilities = Column(String)
    preferred_stock = Column(String)
    common_stock = Column(String)
    retained_earnings = Column(String)
    accumulated_other_comprehensive_income_loss = Column(String)
    othertotal_stockholders_equity = Column(String)
    total_stockholders_equity = Column(String)
    total_equity = Column(String)
    total_liabilities_and_stockholders_equity = Column(String)
    minority_interest = Column(String)
    total_liabilities_and_total_equity = Column(String)
    total_investments = Column(String)
    total_debt = Column(String)
    net_debt = Column(String)
    link = Column(String)
    final_link = Column(String)
    ticker = Column(String, primary_key=True)
    current_date = Column(Date)


Base.metadata.create_all(engine)


=== Content of frontend/src/index.js ===

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();


=== Content of frontend/src/App.js ===

import React, { useState, useEffect } from 'react';
import './App.css';
import axios from 'axios';


function App() {
  const [periods, setPeriods] = useState([]);
  const [tickers, setTickers] = useState([]);
  const [selectedPeriod, setSelectedPeriod] = useState("");
  const [selectedTicker, setSelectedTicker] = useState("");
  const [data, setData] = useState([]);

  useEffect(() => {
      
    axios.get('/fa-balance/options')
      .then(response => {
        setPeriods(response.data.periods);
        setTickers(response.data.tickers);
      })
      .catch(error => {
        console.error('There was an error fetching data', error);
      });

  }
  
  
  , []);

  const fetchData = () => {
    fetch(`/fa-balance/?period=${selectedPeriod}&ticker=${selectedTicker}`)
      .then(response => response.json())
      .then(data => setData(data));
  };

  return (
    <div className="App">
      <select onChange={e => setSelectedPeriod(e.target.value)}>
        {periods.map(period => <option key={period} value={period}>{period}</option>)}
      </select>

      <select onChange={e => setSelectedTicker(e.target.value)}>
        {tickers.map(ticker => <option key={ticker} value={ticker}>{ticker}</option>)}
      </select>

      <button onClick={fetchData}>Show Data</button>

      <table>
        <thead>

          <tr>
            <th>ID</th>
            <th>Period</th>
            <th>Ticker</th>
            <th>Value</th>

          </tr>
        </thead>

        <tbody>
          {data.map(row => (
            <tr key={row.id}>
              <td>{row.id}</td>
              <td>{row.period}</td>
              <td>{row.ticker}</td>
              <td>{row.value}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default App;
